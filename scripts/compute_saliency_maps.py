import os
import logging
import numpy as np
import torch
import pandas as pd
from scipy.stats import zscore
from scipy.io import loadmat

# from scipy.signal import welch
from camcan.parsing import parser
from camcan.params import TIME_TRIAL_LENGTH
from camcan.utils import load_checkpoint, cuda_check
from camcan.network import create_net
from camcan.dataloaders import load_data
from camcan.misc_functions import get_positive_negative_saliency
from pytorch_grad_cam import GuidedBackpropReLUModel

DEVICE = cuda_check()
CHANNELS = ("MAG", "PLANAR1", "PLANAR2")


if __name__ == "__main__":

    parser.add_argument(
        "--use-windows",
        action="store_true",
        help="wether or not to use saliency windows generated by guided backprop.",
    )
    parser.add_argument(
        "--confidence",
        type=float,
        default=0.98,
        help="the confidence needed for a trial to be selected for visualisation",
    )
    parser.add_argument(
        "--saliency",
        default="pos",
        choices=["pos", "neg", "both"],
        type=str,
        help="chooses whether to use positive saliency, negative saliency or the sum of them",
    )
    args = parser.parse_args()

    if args.log:
        log_name = args.model_name
        if args.fold is not None:
            log_name += f"_fold{args.fold}"
        log_name += "_saliency_computations.log"
        logging.basicConfig(
            filename=os.path.join(args.save_path, log_name),
            filemode="a",
            level=logging.INFO,
            format="%(asctime)s %(message)s",
            datefmt="%m/%d/%Y %I:%M:%S %p",
        )
    else:
        logging.basicConfig(
            level=logging.INFO,
            format="%(asctime)s %(message)s",
            datefmt="%m/%d/%Y %I:%M:%S %p",
        )

    if args.eventclf:
        labels = ["visual", "auditory"]  # image is label 0 and sound label 1
    elif args.subclf:
        labels = []
    else:
        labels = ["male", "female"]

    if args.feature == "bins":
        trial_length = 241
    if args.feature == "bands":
        trial_length = 5
    elif args.feature == "temporal":
        trial_length = TIME_TRIAL_LENGTH
    elif args.feature == "cov":
        # TODO
        pass
    elif args.feature == "cosp":
        # TODO
        pass

    if args.sensors == "MAG":
        n_channels = 102
        chan_index = 0
    elif args.sensors == "GRAD":
        n_channels = 204
        chan_index = [1, 2]
    elif args.sensors == "ALL":
        n_channels = 306
        chan_index = [0, 1, 2]

    input_size = (n_channels // 102, 102, trial_length)

    fold = args.fold + 1
    name = f"{args.model_name}_{args.seed}_fold{fold}_{args.sensors}"
    suffixes = ""
    if args.net_option == "custom_net":
        if args.batchnorm:
            suffixes += "_BN"
        if args.maxpool != 0:
            suffixes += f"_maxpool{args.maxpool}"

        name += f"_dropout{args.dropout}_filter{args.filters}_nchan{args.nchan}_lin{args.linear}_depth{args.hlayers}"
        name += suffixes

    if args.subclf:
        n_outputs = min(643, args.max_subj)
    else:
        n_outputs = 2

    sal_path = os.path.join(args.save_path, "saliency_maps", name)
    if not os.path.exists(sal_path):
        os.makedirs(sal_path)

    model_filepath = os.path.join("../models/", name + ".pt")
    net = create_net(args.net_option, name, input_size, n_outputs, DEVICE, args)
    _, net_state, _ = load_checkpoint(model_filepath)
    net.load_state_dict(net_state)
    GBP = GuidedBackpropReLUModel(net, use_cuda=(DEVICE == "cpu"))
    logging.info(net)

    dataframe = (
        pd.read_csv(
            os.path.join(args.data_path, f"participants_info_{args.dattype}.csv"),
            index_col=0,
        )
        .sample(frac=1, random_state=args.seed)
        .reset_index(drop=True)[: args.max_subj]
    )
    subj_list = dataframe["sub"]

    for i, sub in enumerate(subj_list):
        existing_paths = []
        for j, sal_type in enumerate(("pos", "neg")):
            if not args.eventclf:
                for label in labels:
                    lab = "" if args.subclf else f"_{label}"
                    sal_filepath = os.path.join(
                        sal_path,
                        f"{sub}{lab}_{sal_type}_sal_{args.confidence}confidence.npy",
                    )
                    existing_paths.append(os.path.exists(sal_filepath))
            else:
                for i, label in enumerate(labels):
                    sal_filepath = os.path.join(
                        sal_path,
                        f"{sub}_{labels[i]}_{sal_type}_sal_{args.confidence}confidence.npy",
                    )
                    existing_paths.append(os.path.exists(sal_filepath))
        if all(existing_paths):
            continue

        data, targets = load_data(
            dataframe.loc[dataframe["sub"] == sub],
            args.data_path,
            epoched=args.epoched,
            seed=args.seed,
            s_freq=args.sfreq,
            chan_index=chan_index,
            dattype=args.dattype,
            eventclf=args.eventclf,
        )
        if data is None or targets is None:
            continue
        if args.eventclf:
            target_saliencies = [[[], []], [[], []]]
        else:
            target_saliencies = [[], []]
        for trial, label in zip(data, targets):
            X = trial[np.newaxis].type(torch.FloatTensor).to(DEVICE)
            preds = torch.nn.Softmax(dim=1)(net(X)).detach().cpu()
            pred = preds.argmax().item()
            confidence = preds.max()
            if args.subclf:
                label = int(dataframe[dataframe["sub"] == sub].index[0])
            if confidence >= args.confidence and pred == label:
                guided_grads = GBP(X.to(DEVICE), label)
                guided_grads = np.rollaxis(guided_grads, 2, 0)
                pos_saliency, neg_saliency = get_positive_negative_saliency(
                    guided_grads
                )
                if args.eventclf:
                    target_saliencies[label][0].append(pos_saliency)
                    target_saliencies[label][1].append(neg_saliency)
                else:
                    target_saliencies[0].append(pos_saliency)
                    target_saliencies[1].append(neg_saliency)

        for j, sal_type in enumerate(("pos", "neg")):
            if not args.eventclf:
                lab = "" if args.subclf else f"_{labels[label]}"
                sal_filepath = os.path.join(
                    sal_path,
                    f"{sub}{lab}_{sal_type}_sal_{args.confidence}confidence.npy",
                )
                if not os.path.exists(sal_filepath):
                    np.save(sal_filepath, np.array(target_saliencies[j]))
            else:
                for i, label in enumerate(labels):
                    sal_filepath = os.path.join(
                        sal_path,
                        f"{sub}_{labels[i]}_{sal_type}_sal_{args.confidence}confidence.npy",
                    )
                    np.save(sal_filepath, np.array(target_saliencies[i][j]))
